# T2-09: Refactor `reset_player_action_flags` to single-pass tuple comprehension

## Problem
After T1-10, `reset_player_action_flags` uses `enumerate()` correctly but still calls `update_player()` in a loop. Each call creates a new `PokerGameState` with a full tuple rebuild of all players â€” O(n) intermediate objects for n players.

The codebase documents single-pass tuple comprehensions as the preferred pattern for immutable player list updates (see CLAUDE.md "Immutable Updates" section).

## What Changed
Replaced the loop-based approach:
```python
for idx, player in enumerate(game_state.players):
    if idx != game_state.current_player_idx or not exclude_current_player:
        game_state = game_state.update_player(player_idx=idx, has_acted=False)
return game_state
```

With a single-pass tuple comprehension:
```python
updated_players = tuple(
    player if (exclude_current_player and idx == game_state.current_player_idx)
    else player.update(has_acted=False)
    for idx, player in enumerate(game_state.players)
)
return game_state.update(players=updated_players)
```

This creates one new tuple and one new `PokerGameState` instead of n intermediate objects.

## Test Verification
Existing T1-10 tests (`test_reset_flags_uses_index_not_name`, `test_reset_flags_resets_all_when_not_excluding`) verify identical behavior and pass unchanged.
