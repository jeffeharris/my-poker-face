# T1-02: Hand Evaluator Sort Bug — RE-VERIFY

## Finding

**Status**: CONFIRMED (display-only impact)

## Problem

The original triage claim was that line 871-873 has a `sorted()` call that breaks comparison. The line reference was wrong (file is 177 lines), but the bug IS real — it exists at **`poker/poker_game.py:876-877`** in the `determine_winner` function.

### The Bug

Lines 876-877:
```python
evaluated_hands.sort(key=lambda x: sorted(x[1]["kicker_values"]), reverse=True)
evaluated_hands.sort(key=lambda x: sorted(x[1]["hand_values"]), reverse=True)
```

`sorted()` re-sorts already-descending values into ascending order, which **changes element order** for non-uniform lists. This breaks lexicographic comparison for hands like two-pair.

### Example

- Hand A: Aces and Tens → `hand_values = [14, 14, 10, 10]` → `sorted()` = `[10, 10, 14, 14]`
- Hand B: Kings and Queens → `hand_values = [13, 13, 12, 12]` → `sorted()` = `[12, 12, 13, 13]`

With `reverse=True`, Python compares `[10, 10, 14, 14]` vs `[12, 12, 13, 13]` element-by-element. First element: 10 < 12, so Hand B sorts first. **Wrong** — Aces and Tens should beat Kings and Queens.

### Impact

- **Pot distribution is NOT affected** — the per-tier sort at lines 824-825 correctly uses values without `sorted()`.
- **Display is affected** — `best_overall_hand` (used for `winning_hand`, `hand_name`, `hand_rank` in the result) may pick the wrong hand when multiple players are in evaluated_hands from different side-pot tiers.

## Fix

Remove the `sorted()` wrapper at lines 876-877 to match the correct pattern at lines 824-825:

```python
# Before (broken):
evaluated_hands.sort(key=lambda x: sorted(x[1]["kicker_values"]), reverse=True)
evaluated_hands.sort(key=lambda x: sorted(x[1]["hand_values"]), reverse=True)

# After (correct):
evaluated_hands.sort(key=lambda x: x[1]["kicker_values"], reverse=True)
evaluated_hands.sort(key=lambda x: x[1]["hand_values"], reverse=True)
```

## Test

Test verifies that when determining the overall best hand across evaluated hands, a two-pair of Aces+Tens correctly beats Kings+Queens (which would fail with `sorted()` wrapping).
