# T1-21: Refactor `get_next_active_player_idx` to return `Optional[int]`

## Status: COMPLETED

## Problem

T1-08 changed `get_next_active_player_idx` to raise `ValueError` when no active players exist. This broke production games where all players are all-in or folded (valid game states that should trigger showdown, not crash).

The original behavior (returning `starting_idx`) was reverted as a hotfix, but the proper solution is to return `None` to explicitly signal "no active players" and force callers to handle it.

## Context

When no active players exist (all folded/all-in), the game should:
1. End the betting round
2. Proceed to showdown or determine winner

This is NOT an error state — it's a normal game flow.

## Changes Required

### 1. `poker/poker_game.py` — Core function changes

**`get_next_active_player_idx` (line 620):**
```python
# Change return type
def get_next_active_player_idx(players: Tuple[Player, ...], relative_player_idx: int) -> Optional[int]:

# Change the no-active-players return (around line 645-647)
# FROM:
return starting_idx
# TO:
return None
```

**`advance_to_next_active_player` (line 649):**
```python
# Change return type and handle None
def advance_to_next_active_player(game_state: PokerGameState) -> Optional[PokerGameState]:
    next_idx = get_next_active_player_idx(players=game_state.players,
                                          relative_player_idx=game_state.current_player_idx)
    if next_idx is None:
        return None  # Signal: no active players, betting should end
    return game_state.update(current_player_idx=next_idx)
```

**`set_betting_round_start_player` (lines 564, 567):**
- These calls need to handle `None` return
- If `None`: the betting round shouldn't start (hand should end)
- Add check and raise `ValueError("Cannot start betting round with no active players")` — this IS an error at this point

**`start_next_hand` (line 735):**
- This call finds the new dealer
- If `None`: no valid dealer exists (shouldn't happen if dead players are removed first)
- Add check and raise `ValueError("No active players for dealer assignment")`

### 2. `flask_app/handlers/game_handler.py` — Main game loop

**`handle_ai_action` (line 1241):**
```python
# FROM:
game_state = advance_to_next_active_player(game_state)

# TO:
game_state = advance_to_next_active_player(game_state)
if game_state is None:
    # No active players — betting round is complete, proceed to showdown
    return handle_betting_complete(game_id)
```

Note: Identify the existing function that handles end-of-betting (likely involves `determine_winner` or phase advancement). Use that.

### 3. `flask_app/routes/game_routes.py` — HTTP endpoints

**Line 1015 and 1274:**
Same pattern as game_handler.py — check for `None` and trigger showdown/winner logic.

### 4. `experiments/run_ai_tournament.py` — Tournament runner

**Lines 1048 and 1075:**
Same pattern — check for `None` and proceed to showdown.

### 5. Update imports

Add `Optional` to typing imports in all modified files:
```python
from typing import Optional, ...
```

## Test Updates

**`tests/test_triage_T1_08.py`:**
Update tests to expect `None` instead of `starting_idx`:
```python
def test_returns_none_when_no_active_players(self):
    players = (
        _make_player("A", is_folded=True),
        _make_player("B", is_all_in=True),
    )
    assert get_next_active_player_idx(players, 0) is None
```

**Add integration test:**
Create `tests/test_all_in_showdown.py` to verify:
- Game with all players all-in proceeds to showdown (no crash)
- Game with all but one folded determines winner (no crash)

## Verification

```bash
# Run the specific test
python3 -m pytest tests/test_triage_T1_08.py -v

# Run broader game tests
python3 -m pytest tests/ -k "showdown or all_in or winner" -v

# Run full test suite
python3 -m pytest tests/ -v
```

## Commit

```
fix(T1-21): return Optional[int] from get_next_active_player_idx

- Return None instead of starting_idx when no active players found
- Update advance_to_next_active_player to return Optional[PokerGameState]
- Update all callers to handle None by triggering showdown
- Fixes games crashing when all players are all-in or folded
```

## Implementation Notes

### Changes Made

1. **`poker/poker_game.py`**:
   - `get_next_active_player_idx()`: Changed return type to `Optional[int]`, returns `None` when no active players
   - Added `starting_idx = relative_player_idx % player_count` to normalize the starting index (fixes infinite loop when `relative_player_idx` exceeds player count, e.g., `dealer_idx + 2` in pre-flop for 2-player games)
   - `advance_to_next_active_player()`: Changed return type to `Optional[PokerGameState]`, returns `None` when no active players
   - `set_betting_round_start_player()`: Changed return type to `Optional[PokerGameState]`, returns `None` when no active players
   - `reset_game_state_for_new_hand()`: Added `ValueError` check for dealer assignment (defensive, shouldn't happen in normal play)

2. **`poker/poker_state_machine.py`**:
   - `initialize_hand_transition()`: Handles `None` from `set_betting_round_start_player()` by skipping to SHOWDOWN
   - `initialize_betting_round_transition()`: Handles `None` from `set_betting_round_start_player()` by skipping to SHOWDOWN

3. **Callers already handled** (verified no changes needed):
   - `flask_app/handlers/game_handler.py:1241-1244`: Already handles `None` correctly
   - `flask_app/routes/game_routes.py:1015-1018, 1277-1280`: Already handles `None` correctly
   - `experiments/run_ai_tournament.py:1048-1051, 1078-1081`: Already handles `None` correctly

### Tests Added

- `TestAdvanceToNextActivePlayer`: Tests for `advance_to_next_active_player()` returning `None`
- `TestSetBettingRoundStartPlayer`: Tests for `set_betting_round_start_player()` returning `None` in pre-flop and post-flop scenarios
