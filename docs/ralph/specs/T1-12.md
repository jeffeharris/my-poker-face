# T1-12: RE-VERIFY Socket Memory Leak in useSocket.ts

## Finding (claimed)
TRIAGE says `onConnect`/`onDisconnect` listeners are added via `socket.on()` at lines 19-25 but never explicitly removed, causing a memory leak.

## Investigation

### Code Analysis
File: `react/react/src/hooks/useSocket.ts`

The `useEffect` (line 14) creates a **new** `io()` socket on each effect run (line 16). Listeners are attached to this local socket instance (lines 19-25). The cleanup function (lines 27-29) calls `socket.disconnect()` on that same local instance.

### socket.io-client `disconnect()` Behavior

In socket.io-client v4.x, calling `socket.disconnect()`:
1. Emits the `disconnect` event
2. Calls `socket.destroy()` internally
3. `destroy()` removes all listeners via `socket.off()` / `removeAllListeners()`
4. Closes the underlying transport/connection

The socket instance is effectively disposed — no listeners survive after `disconnect()`.

### No Listener Accumulation

Each effect execution creates a **new** socket instance. The previous instance is disconnected (and fully cleaned up) in the effect's return function. There is no shared socket object that accumulates listeners across re-renders.

The `connect()` function (line 33-37) does create a new socket without explicit listener cleanup, but:
- It only fires if `socketRef.current` is null or not connected
- The manually-created socket doesn't have `onConnect`/`onDisconnect` listeners attached (those are only added in the effect)
- This is a minor inconsistency but not a memory leak

## Verdict

**Dismissed — false positive.** `socket.disconnect()` in socket.io-client removes all listeners as part of its destroy lifecycle. Each effect creates a fresh socket, so no listener accumulation occurs.
