# T2-18: UsageTracker singleton not thread-safe

## Problem

`UsageTracker.get_default()` uses a check-then-act pattern without synchronization:

```python
@classmethod
def get_default(cls) -> "UsageTracker":
    if cls._instance is None:      # Thread A checks
        cls._instance = cls()       # Thread B also checks before A sets
    return cls._instance
```

Multiple threads (e.g., `ThreadPoolExecutor` in `experiments/run_ai_tournament.py`) can race and create separate instances. This leads to redundant pricing caches and stale cache after invalidation.

## Fix

Added double-checked locking with `threading.Lock`:

```python
_instance_lock = threading.Lock()

@classmethod
def get_default(cls) -> "UsageTracker":
    if cls._instance is None:
        with cls._instance_lock:
            if cls._instance is None:
                cls._instance = cls()
    return cls._instance
```

The outer check avoids lock acquisition in the common case (instance already exists). The inner check prevents duplicate creation when multiple threads pass the outer check simultaneously.

## Test

`tests/test_usage_tracker_thread_safety.py` â€” spawns 10 threads calling `get_default()` concurrently and verifies all return the same instance (same `id()`).
