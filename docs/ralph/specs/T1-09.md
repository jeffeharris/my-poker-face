# T1-09: Missing `max_winnable` data — RE-VERIFY

## Verdict: Dismissed (False Positive)

## Claimed Problem
TRIAGE claimed `all_players_bets` isn't available in scope within the enricher callback.

## Investigation

### Closure Scope Analysis

The enricher is created inside `make_decision_with_resilience` (`poker/controllers.py`):

1. **Line 781**: `game_state = self.state_machine.game_state` — local variable assigned
2. **Line 791**: `def make_enricher(...)` — outer function defined
3. **Line 793**: `def enrich_capture(capture_data)` — inner function (the actual enricher)
4. **Line 794**: `player = game_state.current_player` — accesses `game_state` via closure
5. **Line 808**: `all_players_bets = [(p.bet, p.is_folded) for p in game_state.players]` — same closure access
6. **Line 809-814**: `calculate_max_winnable(...)` — called with correctly scoped variables

### Key Facts

- `game_state` is a local variable in the enclosing scope of `make_enricher` and `enrich_capture`. Python closures correctly capture this.
- `game_state` is never reassigned after line 781, so there's no stale-closure risk.
- `calculate_max_winnable` is imported at line 42 from `poker.decision_analyzer` (defined at `poker/decision_analyzer.py:26`).
- All parameters passed to `calculate_max_winnable` (`player_bet`, `player_stack`, `cost_to_call`, `all_players_bets`) are derived from the same `game_state` closure variable.

### Conclusion

The finding is a false positive. `game_state` is properly in closure scope, `all_players_bets` is computed from it correctly, and `calculate_max_winnable` receives valid parameters. There is no scoping issue.
